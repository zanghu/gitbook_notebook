## 使用CRC32算法生成哈希值的问题分析

### 背景：CRC32算法生成哈希值

项目需要GTR系统结合行内全文检索平台实现仓库代码全文检索功能，为此需要为百万-千万级的源码文件建立索引。

本地的文件索引保存在10张数据表中，确定每个文件应该存在哪张表中的方式是：

STEP 1: 根据文件名、文件仓库名等要素为文件计算一个哈希值；
STEP 2: 哈希值 % 10（表的数量）得到该文件需要插入的表的标识。

外协小伙伴在编写哈希计算部分的代码时，选择使用`CRC32`作为哈希值生成算法（经了解是因为之前该同事参考某老旧GOLANG数据库框架的时候，看到其中某处使用`CRC32`作为哈希值计算工具，云云）。在本周代码评审过程中，有同事提出`CRC32`并不适合当前应用场景，里有主要是该算法相比`MD5`、`SHA-1`等算法更容易产生碰撞。

回去调研了一下，总结放在下一章

### 分析：CRC32和MD5的区别

* 名称：`CRC`的全称为CyclicRedundancyCheck，中文名称为循环冗余校验。

* 原理：以32位循环冗余校验多项式算法，来计算一个字符串，返回一个（可能带符号的）整数

*应用：它是一类重要的线性分组码，编码和解码方法简单，检错和纠错能力强，在通信领域广泛地用于实现差错控制。实际上，除数据通信外，CRC在其它很多领域也是大有用武之地的。例如我们读软盘上的文件，以及解压一个ZIP文件时，偶尔会碰到“BadCRC”错误，由此它在数据存储方面的应用可略见一斑。

