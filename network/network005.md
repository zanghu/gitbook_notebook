## 网络：Restful API 详解


参考资料

菜鸟教程：[RESTful 架构详解](https://www.runoob.com/w3cnote/restful-architecture.html)

阮一峰的博客：[理解RESTful架构](http://www.ruanyifeng.com/blog/2011/09/restful.html)

简书：[HTTP 的幂等性 分析 POST 表单重复提交](https://www.jianshu.com/p/84a583e540d2)

### 1.要点总结

（1） URI、GET、POST、PUT、DELETE都不是HTTP特有的，实际上是Retful API的特性，只不过目前应用层协议只有HTTP遵循了Restful API的要求。

（2） GET、POST、PUT、DELETE的动词操作再HTTP中的原始定义，注意每一种操作的幂等性和安全性。

| 动词 | HTTP定义 | 幂等性 | 安全性 |
| --- | --- |--- |--- |
| GET | HTTP GET方法用于获取资源，不应有副作用，所以是幂等的。 | 是 | 安全 |
| POST | HTTP POST方法用于创建资源，所对应的URI并非创建的资源本身，而是去执行创建动作的操作者，有副作用，不满足幂等性。 | 否 | 不安全 |
| PUT | HTTP PUT方法用于创建或更新操作，所对应的URI是要创建或更新的资源本身，有副作用，它应该满足幂等性。 | 是 | 不安全 |
| DELETE | HTTP DELETE方法用于删除资源，有副作用，但它应该满足幂等性。 | 是 | 不安全 |

注意这里安全性的定义是动词是否会对服务端维护的资源进行修改。

（3）**客户端获取的只是资源的表述而已，而不是资源本身**。 例如文本资源可以采用html、xml、json等格式，图片可以使用PNG或JPG展现出来。

那么客户端如何知道服务端提供哪种表述形式呢?答案是可以通过HTTP内容协商，客户端可以通过Accept头请求一种特定格式的表述，服务端则通过Content-Type告诉客户端资源的表述形式。

（4）REST原则中的无状态通信原则。

初看一下，好像自相矛盾了，既然无状态，何来状态转移一说?

其实，这里说的无状态通信原则，并不是说客户端应用不能有状态，而是指服务端不应该保存客户端状态。

（4.1）应用状态与资源状态

实际上，状态应该区分应用状态和资源状态，客户端负责维护应用状态，而服务端维护资源状态。

客户端与服务端的交互必须是无状态的，并在每一次请求中包含处理该请求所需的一切信息。

服务端不需要在请求间保留应用状态，只有在接受到实际请求的时候，服务端才会关注应用状态。

这种无状态通信原则，使得服务端和中介能够理解独立的请求和响应。

在多次请求中，同一客户端也不再需要依赖于同一服务器，方便实现高可扩展和高可用性的服务端。

但有时候我们会做出违反无状态通信原则的设计，例如利用Cookie跟踪某个服务端会话状态，常见的像J2EE里边的JSESSIONID。

这意味着，浏览器随各次请求发出去的Cookie是被用于构建会话状态的。

当然，如果Cookie保存的是一些服务器不依赖于会话状态即可验证的信息（比如认证令牌），这样的Cookie也是符合REST原则的。

（4.2）应用状态的转移
状态转移到这里已经很好理解了， "会话"状态不是作为资源状态保存在服务端的，而是被客户端作为应用状态进行跟踪的。客户端应用状态在服务端提供的超媒体的指引下发生变迁。服务端通过超媒体告诉客户端当前状态有哪些后续状态可以进入。

这些类似"下一页"之类的链接起的就是这种推进状态的作用——指引你如何从当前状态进入下一个可能的状态。