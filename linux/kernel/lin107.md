## 并发编程：强内存序模型和弱内存序模型

### 参考资料

知乎：[内存顺序（Memory Order）](https://zhuanlan.zhihu.com/p/94421667)

知乎：[理解弱内存顺序模型](https://zhuanlan.zhihu.com/p/94421667)

### 1.强弱内存序模型的概念

先讨论单个CPU，现代CPU为了提高执行效率，是能偷跑就偷跑的（还美其名曰ILP，指令级别并行化）。比如你写这样一个代码：

```
a = 1
b = 2
c = a + b
```

前面两条指令谁先跑，“效果”是一样的。既然如此，CPU就有可能（只是有可能，但有可能就够了。另外编译器也可能参与其中一同作恶，这种变体我们先忽略）让b=2先跑，或者让a=1或者b=2同时跑，对CPU来说，我只保证效果符合语义，实际如何执行，你别管。

这种方法对于每个CPU各玩各的，没有问题，但放到多个CPU共享数据的时候就有问题了。

一个CPU要提供数据给其他CPU，可能它会这样写程序：

```
data->a1 = data1;
data->a2 = data2;
data->a3 = data3;
...
data->ready = true;
```

其他CPU就反复读这个data->ready，如果它变成true了，我们就开始读里面的数据。但光从那个写的CPU的角度呢，反正a1, a2, d3, ready也没有啥关系，先写谁不是写啊。这些数据到达内存的顺序就可能是随机的。甚至可能会发生其他的CPU之间看到的顺序都不一样。

这时就需要一个规定了：到底我们看到的内存生效的顺序是怎么样的？这个就叫内存顺序模型。无论是强顺序模型还是弱顺序模型，都指向这个规矩，只是规矩的要求大方向不同而已。有这个规矩，才能称为SMP，或者说是一个Consistent的SMP系统。

SMP的Consistency包括两个问题：内存操作的原子化和内存操作顺序的保证。前者说明的是，我做一个内存操作，什么是原子的？会不会我写入一个寄存器，被别人看到我只写了一半？后者说明的是，我执行了多个原子操作，别人能否按我要求的顺序看见我这些操作？

现在我们重点看顺序问题。

首先我们先建立两个概念：

程序顺序：程序给出的指令的执行顺序，这代表程序员的意欲。

观察顺序：这是各个CPU看到的在内存中发生的顺序，请注意了，这不是内存真的写入数据的顺序，而是所有的“观察者”看到的内存中发生更改的顺序。

**强顺序模型（又叫TSO，Total Store Order）**，是一种靠向程序顺序的顺序模型。所谓Total，就是说，内存（在写操作上）是有一个全局的顺序的（所有人看到的一样的顺序），就好像在内存上的每个Store动作必须有一个排队，一个弄完才轮到另一个，这个顺序和你的程序顺序直接相关。所有的行为组合只会是所有CPU内存程序顺序的交织，不会发生和程序顺序不一致的地方。x86、AMD64（AMD和Intel的个人64位处理器都是这种架构）和SPARK都用了这个内存模型。

这个方式对程序员更友好，但对芯片实现者不友好，因为如果用户没有这个顺序要求，CPU为了TSO的承诺，有执行资源也只能瞪眼看着，这影响效率。

**弱内存模型（简称WMO，Weak Memory Ordering）**,是把是否要求强制顺序这个要求直接交给程序员的方法。换句话说，CPU不去保证这个顺序模型（除非他们在一个CPU上就有依赖），程序员要主动插入内存屏障指令来强化这个“可见性”。也没有一个全局的对所有CPU都是一样的Total Order。

用上面的例子来考虑这个问题，如果我们要data.ready生效的时候，之前的写入都全局可见，那么我可以这样写：

```
data->a1 = data1;
data->a2 = data2;
data->a3 = data3;
...
write_memory_barriar();
data->ready = true;
```

这样，其他CPU看见ready变成true的时候，其他的a1, a2肯定都已经赋值了。

但由于没有Total Order，其他CPU也要对应和这个写方同步：

```
ready = data->ready;
read_memory_barriar();
if (ready) {
  mydata1 = data->a1;
   ...
}
```

Ia64（Intel面向服务器的安腾处理器采用这种架构），PowerPC，MIPS，ARM都是这种模型。

### 2.强弱内存序的体系结构

强内存序模型：X86、AMD64（AMD和Intel的个人64位处理器都是这种架构）和SPARK都用了这个内存模型。

弱内存序模型：Ia64（Intel面向服务器的安腾处理器采用这种架构），PowerPC，MIPS，ARM都是这种模型。






