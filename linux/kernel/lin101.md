## Linux Kernel: 双向链表 LIST_HEAD

参考资料：深入理解Linux内核（第三版）

参考资料：[linux 内核宏container_of剖析](https://zhuanlan.zhihu.com/p/54932270)

### 1.结构定义

`Linux`的双向链表的节点定义非常简单

```c
struct list_head {
    struct list_head *next, *prev;
};
```

这一链表的奇妙之处在于，该链表没有一般数据结构教材中介绍的、用于承载数据的`data`成员，其承载数据的方式是将每个`list_node`对象“埋入”一个数据对象中（典型的比如作为`task_struct`对象的一个成员），通过一种“内核黑客”的方式（具体实现是利用了`container_of`宏函数）实现了根据每个`list_node`对象的地址来找到其所“埋入”的宿主（`task_struct`）对象的地址。

链表“埋入”的示意图：

![](/assets/lin101_001.PNG)

### 2.宏函数offsetof

功能：结构体类型`TYPE`具有名为`MEMBER`的属性，求`MEMBER`属性的地址相对于其所在的结构体对象的起始地址的偏移量，单位：字节。

定义:
```c
// TYPE是某个结构体类型的名称，MEMBER是结构体类型TYPE的某个属性的名称。
#define offsetof(TYPE, MEMBER) ((size_t) &((TYPE*)0)->MEMBER)
```

这里假设了编译器的两个行为：

（1）只要结构体定义相同，在程序任何位置编译出的结构体对象的内存结构中，结构体对象的任一成员相对于结构体的相对位置是相同的；

（2）`&((TYPE*)0)->MEMBER`的值是在**编译期**而不是**运行期**决定的，因此程序不会实际访问地址 `0x00`导致程序崩溃。


### 3.宏函数container_of

#### 2.1 ({})表达式的作用

`({})`这个表达式返回最后一个表达式的值。比如x=({a;b;c;d;})，最终x的值应该是d。

#### 2.2 typeof关键字获取变量的类型

这个关键字是GNU C语言关键字的拓展，返回变量的类型，具体可以看GCC里面的介绍：

[https://gcc.gnu.org/onlinedocs/gcc/Typeof.html](https://gcc.gnu.org/onlinedocs/gcc/Typeof.html)

示例代码：
```c
void main(void)
{
    int a = 6;
    typeof(a) b =9;
    printf("%d %d\n",a,b);
}
```

#### 2.3 container_of剖析

看完上面的几个知识点，再来看container_of这个宏就显得非常清晰了。我把解析部分写在下面的代码注释里面。

```c
#define offsetof(TYPE, MEMBER) ((size_t) &((TYPE*)0)->MEMBER)
#define container_of(ptr, type, member) ({          \
        const typeof( ((type *)0)->member ) *__mptr = (const typeof( ((type *)0)->member ) *)(ptr); \
        (type *)( (char *)__mptr - offsetof(type,member) );})
```

由此可见`container_of`的功能是：根据结构体类型`type`对象的成员`member`的地址，反推得到结构体对象的地址。

#### 2.4 

```c
#define list_entry(ptr, type, member) container_of(ptr, type, member)
```