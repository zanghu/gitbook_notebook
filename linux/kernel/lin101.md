## Linux Kernel: 双向链表 LIST_HEAD

参考资料：深入理解Linux内核（第三版）

参考资料：[linux 内核宏container_of剖析](https://zhuanlan.zhihu.com/p/54932270)

### 1.结构定义

`Linux`的双向链表的节点定义非常简单

```c
struct list_head {
    struct list_head *next, *prev;
};
```

这一链表的奇妙之处在于，该链表没有一般数据结构教材中介绍的、用于承载数据的`data`成员，其承载数据的方式是将每个`list_node`对象“埋入”一个数据对象中（典型的比如作为`task_struct`对象的一个成员），通过一种“内核黑客”的方式（具体实现是利用了`container_of`宏函数）实现了根据每个`list_node`对象的地址来找到其所“埋入”的宿主（`task_struct`）对象的地址。

链表“埋入”的示意图：

![](/assets/lin101_001.PNG)

### 2.宏函数offsetof

功能：结构体类型`TYPE`具有名为`MEMBER`的属性，求`MEMBER`属性的地址相对于其所在的结构体对象的起始地址的偏移量，单位：字节。

定义:
```c
#define offsetof(TYPE, MEMBER) ((size_t) &((TYPE*)0)->MEMBER)
```

其中：`TYPE`是某个结构体类型的名称，`MEMBER`是结构体类型`TYPE`的某个属性的名称。



这里利用了两个对编译器行为的假设：

（1）



### 3.宏函数container_of

#### 2.1、({})表达式的作用

`({})`这个表达式返回最后一个表达式的值。比如x=({a;b;c;d;})，最终x的值应该是d。

#### 2.2、typeof关键字获取变量的类型

这个关键字是GNU C语言关键字的拓展，返回变量的类型，具体可以看GCC里面的介绍：

[https://gcc.gnu.org/onlinedocs/gcc/Typeof.html](https://gcc.gnu.org/onlinedocs/gcc/Typeof.html)

示例代码：
```c
void main(void)
{
    int a = 6;
    typeof(a) b =9;
    printf("%d %d\n",a,b);
}
```
4.3、(struct st*)0的作用



struct st{
    int a;
    int b;
}*p_st,n_st;

void main(void)
{
    printf("%p\n",&((struct st*)0)->b);
}
上面的代码

(struct st*)0
这个的意思就是把这个结构体放到0刻度上面开始量了，然后量到哪里呢？

&((struct st*)0)->b)
这个就体现出来了，量到b的位置。所以上面的输出应该是4。

看完上面的解释，应该知道下面这两个代码的功能是一样的。

typeof ((struct st*)0)->b) c; // 取b的类型来声明c
int c;
其实不只是对于0，用其他数字一样是有效的，比如下面的代码，编译器关心的是类型，而不在乎这个数字。

printf("%p\n",&((struct st*)4)->b  -4 );
这文章写了有几天了，但是一直不想直接发出去，因为我觉得这个核心点总是没有找到一个特别好的论证方法，看完上面后，大概对这种测量应该有点感觉了吧，如果现在需要你把一个数组的首地址设置为0，要怎么做呢？

先思考一下，假设这里延迟了几分钟。

代码如下：

struct A {
    short array[100];
};

int main(int argc, char *argv[])
{
    int i = 10;

    A* a = (A*)0;
    printf("%p %d %d\n",a,sizeof(short), &a->array[20]);
    getchar();
    return 1;
}
//输出 00000000 2 40
有什么办法不使用==struct A *== 直接把数组的地址放到0位置呢？目前我还没有找到其他更好的办法，如果有好的建议的，请留言给我。

4.4、offsetof(TYPE, MEMBER)
#define offsetof(TYPE, MEMBER) ((size_t) &((TYPE*)0)->MEMBER)
size_t 这个有不懂的可以百度下，就是unsigned 的整数，在32位和64位下长度不同，所以这个offsetof就是获取结构体的偏移长度。

4.5、const int* p的作用
上面的宏定义里面还有一个小知识点

const typeof( ((type *)0)->member ) *__mptr
上面的代码可以简写成

const int * __mptr
这个说明什么问题呢？这个说明__mptr指向的整型数据是一个const（常数）。
这就涉及到两外两个知识

int * const __mptr;//表示__mptr的值不能改变
//和
const int * const __mptr; //表示__mptr不能改变而且指向的内容也不能改变