## Linux: 内核模式与用户模式探索分析

### 1.彻底摒弃“程序运行时存在某种解释器”的错误设想

&emsp&emsp**内核模式**和**用户模式**是同一进程的两种不同状态。

&emsp&emsp操作系统中设计`内核模式`和`用户模式`的**根本原因**在于CPU的硬件设计，即CPU将指令分为不同的权限级别，当用户程序以错误方式的执行CPU指令时，权限级别越高的指令造成的危害越严重。

&emsp&emsp为了避免高权限指令执行时发生危害整个系统运行（而不仅仅是当前进程）的错误，操作系统将进程的运行状态分为两种模式：内核模式和用户模式。确保只有特定的应用程序崩溃，而不是整个系统崩溃，这是用户模式的价值。对于权限级别较低（比较安全）的那些CPU指令，进程可以在用户模式中执行，对于权限级别较高（比较危险）的那些CPU指令，进程必须在内核模式中执行。内核模式和用户模式是**硬件层的CPU指令权限在系统层的体现**。x86 CPU硬件实际上提供了四个保护环：0, 1, 2和3，而操作系统通常只使用环0（内核）和3（用户）。

![](/assets/lin020_001.png)

&emsp&emsp Linux操作系统为了避免用户直接执行那些“危险的”指令，将涉及这些指令的操作都封装成内核中的函数，这些函数就是所谓的**系统调用（system call）**。系统调用相当于在用户和指令间插入一个中间层，对用户提供具有更强“业务逻辑”的函数接口，有操作系统预先设计好这些函数内的内部逻辑，避免用户亲自设计逻辑来操作危险的指令发生不可挽回的错误。

&emsp&emsp在Linux环境下，进入内核模式一般通过执行系统调用来实现。用户进程通过**中断**指令`int 0x80`进入系统调用，在进入系统调用后会首先将进程由`用户模式`切换到`内核模式`并保存上下文（同一个进程在内核模式和用户模式下游不同的堆栈和寄存器），在系统调用结束前再将进程由`内核模式`切换到`用户模式`。

### 2.系统调用与C库函数

#### 2.1 二者的区别与联系



#### 2.2 哪些函数用到了系统调用

**多项选择**：面哪些函数调用必须进入内核才能完成？

&emsp A.fopen
&emsp B.exit
&emsp C.memcpy
&emsp D.strlen

参考答案：AB

本人亲测memcpy函数确实不会进入内核，依据是：

对一个包含memcpy的程序使用`-static`参数（强制静态链接）编译出二进制可执行文件Test，再使用`objdump`显示汇编码：

```shell
$ gcc -g - Wall -m32 -static test.c -o Test
$ objdump -S Test
```

检查汇编码中memcpy函数的段落，确定其中没有对其他函数的调用也没有`int 0x80`之类的内容。

这就引发了一个疑问：众所周知memcpy这样设计内存操作的函数有可能因为内存越界导致段错误，而段错误则是由于中断后中断进程的处理导致，这种涉及到缺页、中断之类的处理，显然不是用户模式的工作，那么为什么还说memcpy不涉及进入内核呢？

原因在于：