## Linux: 内核模式与用户模式探索分析

### 1.操作系统中进程两种模式的起源

**彻底摒弃“程序运行时存在某种解释器”的错误设想！**

&emsp&emsp**内核模式**和**用户模式**是同一进程的两种不同状态。

&emsp&emsp操作系统中设计`内核模式`和`用户模式`的**根本原因**在于CPU的硬件设计，即CPU将指令分为不同的权限级别，当用户程序以错误方式的执行CPU指令时，权限级别越高的指令造成的危害越严重。

&emsp&emsp为了避免高权限指令执行时发生危害整个系统运行（而不仅仅是当前进程）的错误，操作系统将进程的运行状态分为两种模式：内核模式和用户模式。确保只有特定的应用程序崩溃，而不是整个系统崩溃，这是用户模式的价值。对于权限级别较低（比较安全）的那些CPU指令，进程可以在用户模式中执行，对于权限级别较高（比较危险）的那些CPU指令，进程必须在内核模式中执行。内核模式和用户模式是**硬件层的CPU指令权限在系统层的体现**。x86 CPU硬件实际上提供了四个保护环：0, 1, 2和3，而操作系统通常只使用环0（内核）和3（用户）。

![](/assets/lin020_001.png)

&emsp&emsp Linux操作系统为了避免用户直接执行那些“危险的”指令，将涉及这些指令的操作都封装成内核中的函数，这些函数就是所谓的**系统调用（system call）**。系统调用相当于在用户和指令间插入一个中间层，对用户提供具有更强“业务逻辑”的函数接口，有操作系统预先设计好这些函数内的内部逻辑，避免用户亲自设计逻辑来操作危险的指令发生不可挽回的错误。

下面的图片UNIX系统的体系结构（UNIX环境高级编程，第三版）：

![](/assets/lin020_003.PNG)

&emsp&emsp在Linux环境下，进入内核模式一般通过执行系统调用来实现。用户进程通过**中断**指令`int 0x80`进入系统调用，在进入系统调用后会首先将进程由`用户模式`切换到`内核模式`并保存上下文（同一个进程在内核模式和用户模式下游不同的堆栈和寄存器），在系统调用结束前再将进程由`内核模式`切换到`用户模式`。

### 2.系统调用与C库函数

#### 2.1 二者的区别与联系

应用程序既可以调用系统调用也可以调用库函数，很多库函数则会调用系统调用。下图显示了这种差别（UNIX环境高级编程，第三版）：

![](/assets/lin020_004.PNG)

#### 2.2 哪些函数用到了系统调用

**多项选择**：面哪些函数调用必须进入内核才能完成？

&emsp A.fopen
&emsp B.exit
&emsp C.memcpy
&emsp D.strlen

**参考答案**：AB

本人亲测memcpy函数确实不会进入内核，依据是：

对一个包含memcpy的程序使用`-static`参数（强制静态链接）编译出二进制可执行文件Test，再使用`objdump`显示汇编码：

```shell
$ gcc -g - Wall -m32 -static test.c -o Test
$ objdump -S Test
```

检查汇编码中memcpy函数的段落，确定其中没有对其他函数的调用也没有`int 0x80`之类的内容。

这就引发了一个疑问：众所周知memcpy这样设计内存操作的函数有可能因为内存越界导致段错误，而段错误则是由于中断后中断进程的处理导致，这种涉及到缺页、中断之类的处理，显然不是用户模式的工作，那么为什么还说memcpy不涉及进入内核呢？

**原因**：`memcpy`程序指令中的内存地址都是虚拟内存空间中的地址，CPU在执行内存拷贝时会首先尝试在虚拟内存缓存DRAM中查找该地址，如果查找失败将引发缺页异常，之后进入缺页异常处理阶段：

1、导致缺页异常的线性地址根本不在进程的“虚存区间”中，段错误。（栈扩展是一种例外情况）
2、地址在“虚存区间”中，但“虚存区间”的访问权限不够；例如“区间”是只读的，而程序想写，段错误
3、权限也够了，但是映射关系没建立；先建立映射关系再说
4、映射关系也建立了，但是页面不在内存中。肯定是换出到交换分区中了，换进来再说
5、页面也在内存中。但页面的访问权限不够。例如页面是只读的，而你想写。这通常就是 “写时拷贝COW” 的情况。

下图给出了页表机制下内存页命中的示意图（深入理解计算机系统第二版，第九章）：

![](/assets/lin020_002.PNG)

如上，内存越界在缺页处理中由此引发段错误（当然并不一定每一次越界都必然引发段错误），而这部分中断是硬件一发的，其处理机制也是由CPU直接转交给中断向量中所指的中断处理句柄完成的，这部分操作的指令并不存在与`memcpy`函数的代码中。从上面的分析还可以看出，正是由于虚拟内存的存在，才使得`memcpy`这样的看似“危险”的内存写操作在用户模式下执行也是安全的。

需要注意，CPU本身并没有对指令所操作的内存的越界检查能力。