## C: dlopen使用实践总结

C程序在运行期加载动态库，一个比较灵活的办法就是使用libdl库中的`dlopen`函数，在程序运行期“打开”指定的动态库。

### 1.示例说明

* **依赖描述**：测试程序`test.c`调用了动态库`libA.so`中的接口，而`libA.so`调用了`libB.so`的函数。

* **实验设计**：测试程序不会直接链接`libA.so`，而是在程序启动后使用`dlopen`等函数打开`libA.so`并调用其中函数。

### 2.编译运行

* 经过实践，正确的做法是：

程序编译期需要链接测试程序的间接依赖库`libB.so`，但无需链接准备用`dlopen`加载的直接依赖库`libA.so`，编译命令如下：

```shell
$ gcc -g -Wall -L path/to/libB test.c -lB -o Test
```

运行命令：

```shell
$ export LD_LIBRARY_PATH=path/to/libB:$LD_LIBRARY_PATH # 指定libB.so搜索目录
$ ./Test
```

* 几种错误

&emsp&emsp如果编译期不链接间接库`libB.so`，那么编译也不会报错（毕竟测试程序中没有直接调用`libB.so`的任何符号），但是运行期程序启动执行到`libA.so`中调用`libB.so`的函数的位置就会报错：缺少符号XXX

&emsp&emsp另外一种错误的做法是，在测试程序中用`dlopen`也打开了`libB.so`，但并未用`dlsym`包装任何库中函数，期望测试程序运行期自动到库`libB.so`中搜索符号，但是实验证实这样做会引发同样的缺少符号的错误。

### 3.实践总结

如果程序中要调用`dlopen`打开静态库，目前个人采用的程序架构设计如下：

![](/assets/c004_001.PNG)

代码如下：











