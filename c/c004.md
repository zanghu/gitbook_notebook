## C: dlopen使用实践总结

C程序在运行期加载动态库，一个比较灵活的办法就是使用libdl库中的`dlopen`函数，在程序运行期“打开”指定的动态库。

### 1.示例说明

* **依赖描述**：测试程序`test.c`调用了动态库`libA.so`中的接口，而`libA.so`调用了`libB.so`的函数。

* **实验设计**：测试程序不会直接链接`libA.so`，而是在程序启动后使用`dlopen`等函数打开`libA.so`并调用其中函数。

### 2.编译运行

* 经过实践，正确的做法是：

程序编译期需要链接测试程序的间接依赖库`libB.so`，但无需链接准备用`dlopen`加载的直接依赖库`libA.so`，编译命令如下：

```shell
$ gcc -g -Wall -L path/to/libB test.c -lB -o Test
```

运行命令：

```shell
$ export LD_LIBRARY_PATH=path/to/libB:$LD_LIBRARY_PATH # 指定libB.so搜索目录
$ ./Test
```

* 几种错误

&emsp&emsp如果编译期不链接间接库`libB.so`，那么编译也不会报错（毕竟测试程序中没有直接调用`libB.so`的任何符号），但是运行期程序启动执行到`libA.so`中调用`libB.so`的函数的位置就会报错：缺少符号XXX

&emsp&emsp另外一种错误的做法是，在测试程序中用`dlopen`也打开了`libB.so`，但并未用`dlsym`包装任何库中函数，期望测试程序运行期自动到库`libB.so`中搜索符号，但是实验证实这样做会引发同样的缺少符号的错误。

### 3.实践总结

如果程序中要调用`dlopen`打开静态库，目前个人采用的程序架构设计如下：

![](/assets/c004_001.PNG)

代码如下：

#### 3.1 load_so：重新封装dlopen等函数，加入异常处理

* **load_so头文件**

```c
/* load_so.h */
#ifndef LOAD_SO_H_
#define LOAD_SO_H_

// 包装dlopen
int wrappedDlopen(void **so_handle, const char *so_path);

// 包装dlsym
int wrappedDlsym(void **method_handle, void *so_handle, const char *method_name);

// 包装dlclose
int warppedDlclose(void *so_handle);

#endif
```

* **load_so源文件**

```c
/* load_so.c */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/time.h>
#include <dlfcn.h>

#include "test__macros.h"

#include "load_so.h"

// 包装dlopen
int wrappedDlopen(void **so_handle, const char *so_path)
{
    CHK_NIL(so_handle);
    CHK_NIL(so_path);

    void *tmp_handle = dlopen(so_path, RTLD_LAZY);
    //fprintf(stderr, "%s\n", dlerror());
    if (tmp_handle == NULL) {
        fprintf(stderr, "dlopen() 打开动态库 %s 失败, dlerror: %s, error.\n", so_path, dlerror());
        return TEST_ERROR;
    }
    *so_handle = tmp_handle;

    return 0;
}

// 包装dlsym
int wrappedDlsym(void **method_handle, void *so_handle, const char *method_name)
{
    CHK_NIL(method_handle);
    CHK_NIL(so_handle);
    CHK_NIL(method_name);

    void *tmp_handle = NULL;
    const char *dl_err = NULL;

    dlerror(); // 清空之前的异常
    tmp_handle = dlsym(so_handle, method_name);
    if ((dl_err = dlerror()) != NULL)  {
        fprintf(stderr, "dlsym失败, dlerror: %s, error.\n", dl_err);
        return TEST_ERROR;
    }
    CHK_NIL(tmp_handle);
    *method_handle = tmp_handle;

    return 0;
}

// 包装dlclose
int warppedDlclose(void *so_handle)
{
    if (so_handle != NULL) {
        int error = 0;
        error = dlclose(so_handle);
        if (error != 0) {
            fprintf(stderr, "dlclose() 关闭动态库失败, dlerror: %s, error.\n", dlerror());
            return TEST_ERROR;
        }
    }

    return 0;
}
```









