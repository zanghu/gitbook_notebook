## C: dlopen使用实践总结

C程序在运行期加载动态库，一个比较灵活的办法就是使用libdl库中的`dlopen`函数，在程序运行期“打开”指定的动态库。

### 1.示例说明

* **依赖描述**：测试程序`test.c`调用了动态库`libA.so`中的接口，而`libA.so`调用了`libB.so`的函数。

* **实验设计**：测试程序不会直接链接`libA.so`，而是在程序启动后使用`dlopen`等函数打开`libA.so`并调用其中函数。

### 2.编译运行

* 经过实践，正确的做法是：

程序编译期需要链接测试程序的间接依赖库`libB.so`，但无需链接准备用`dlopen`加载的直接依赖库`libA.so`，编译命令如下：

```shell
$ gcc -g -Wall -L path/to/libB test.c -lB -o Test
```

运行命令：

```shell
$ export LD_LIBRARY_PATH=path/to/libB:$LD_LIBRARY_PATH # 指定libB.so搜索目录
$ ./Test
```

* 几种错误

&emsp&emsp如果编译期不链接间接库`libB.so`，那么编译也不会报错（毕竟测试程序中没有直接调用`libB.so`的任何符号），但是运行期程序启动执行到`libA.so`中调用`libB.so`的函数的位置就会报错：缺少符号XXX

&emsp&emsp另外一种错误的做法是，在测试程序中用`dlopen`也打开了`libB.so`，但并未用`dlsym`包装任何库中函数，期望测试程序运行期自动到库`libB.so`中搜索符号，但是实验证实这样做会引发同样的缺少符号的错误。

### 3.实践总结

如果程序中要调用`dlopen`打开静态库，目前个人采用的程序架构设计如下：

![](/assets/c004_001.PNG)

代码如下：

#### 3.1 load_so：重新封装dlopen等函数，加入异常处理

* **load_so头文件**

```c
/* load_so.h */
#ifndef LOAD_SO_H_
#define LOAD_SO_H_

// 包装dlopen
int wrappedDlopen(void **so_handle, const char *so_path);

// 包装dlsym
int wrappedDlsym(void **method_handle, void *so_handle, const char *method_name);

// 包装dlclose
int warppedDlclose(void *so_handle);

#endif
```

* **load_so源文件**

```c
/* load_so.c */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/time.h>
#include <dlfcn.h>

#include "test__macros.h"

#include "load_so.h"

// 包装dlopen
int wrappedDlopen(void **so_handle, const char *so_path)
{
    CHK_NIL(so_handle);
    CHK_NIL(so_path);

    void *tmp_handle = dlopen(so_path, RTLD_LAZY);
    //fprintf(stderr, "%s\n", dlerror());
    if (tmp_handle == NULL) {
        fprintf(stderr, "dlopen() 打开动态库 %s 失败, dlerror: %s, error.\n", so_path, dlerror());
        return TEST_ERROR;
    }
    *so_handle = tmp_handle;

    return 0;
}

// 包装dlsym
int wrappedDlsym(void **method_handle, void *so_handle, const char *method_name)
{
    CHK_NIL(method_handle);
    CHK_NIL(so_handle);
    CHK_NIL(method_name);

    void *tmp_handle = NULL;
    const char *dl_err = NULL;

    dlerror(); // 清空之前的异常
    tmp_handle = dlsym(so_handle, method_name);
    if ((dl_err = dlerror()) != NULL)  {
        fprintf(stderr, "dlsym失败, dlerror: %s, error.\n", dl_err);
        return TEST_ERROR;
    }
    CHK_NIL(tmp_handle);
    *method_handle = tmp_handle;

    return 0;
}

// 包装dlclose
int warppedDlclose(void *so_handle)
{
    if (so_handle != NULL) {
        int error = 0;
        error = dlclose(so_handle);
        if (error != 0) {
            fprintf(stderr, "dlclose() 关闭动态库失败, dlerror: %s, error.\n", dlerror());
            return TEST_ERROR;
        }
    }

    return 0;
}
```

#### 3.2 load_A

将dlopen调用动态库过程抽象成一个单例对象资源的管理过程：

* 将`libA.so`看作一类资源，且此类资源是单例的；

* 将“使用`dlopen`打开库的行为”看作是资源单例对象的初始化，“使用`dlclose`关闭库的行为”则看作是资源单例对象释放；

* 将“使用`dlsym`读取`libA.so`中函数并重命名的行为”看作是单例资源对外提供接口方法。

综上，可以将库看作一种资源（libA.so），构建一个单例对象，对外提供一组接口方法（libA.so中的方法通过dlsym取出后重命名）。

这样设计的一个显著好处是：其他代码在调用libA.so中的函数时，不再需要自己编写操作`dlopen`、`dlsym`等函数的代码，实际调用代码和调用普通函数没有区别，使得“libA.so是使用dlopen在运行期打开的”这一细节只与lib_A.c的代码逻辑耦合，而不会影响其他部分代码逻辑。

* **load_A头文件**

```c
/* load_A.h */
#ifndef LOAD_A_H_
#define LOAD_A_H_

// 加载A动态库, 初始化函数指针成员
int loadASo(const char *so_dir);

// 卸载A动态库
int unloadASo();

// 方法重新封装, 方法名后面统一在原方法名基础上加上"so"后缀

// 需要调用的接口函数1
int func1_so();

// 需要调用的接口函数2
int func2_so();

#endif
```

* **load_A源文件**









