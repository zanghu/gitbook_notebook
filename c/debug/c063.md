## GDB: 监视内存指定地址区间数据的变化

参考资料：[Watch a memory range in gdb?](https://stackoverflow.com/questions/11004374/watch-a-memory-range-in-gdb)

参考资料：[GDB 使用详解-----转载](https://www.cnblogs.com/visayafan/archive/2011/09/27/2193632.html)


### 1.概述

一般来说，开发中遇到内存区域被“污染”的问题，首先怀疑是因为内存写越界导致。`valgrind`动态内存检查工具往往有助于定位此类问题的原因，但是如果程序中使用了内存池之类的内存缓冲区机制，此类问题的定位就会变得非常困难。

此时，一种解决方法的思路是：

* STEP 1: 确定出现数据异常的内存段的位置（内存地址区间）；
* STEP 2: 在程序运行期间持续监视此内存区间，观察每次对此区间的写操作，确认是哪一次操作中造成数据污染。

这里就需要用到`GDB`的内存区间监视功能：

```text
watch + [变量][表达式]  当变量或表达式值改变时即停住程序。
rwatch + [变量][表达式] 当变量或表达式被读时，停住程序。
awatch + [变量][表达式] 当变量或表达式被读或被写时，停住程序。
```

### 2.举例

#### 2.1.操作

#### 2.2.测试源码

测试代码: test.c

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct A
{
    char *a;
    char b[2];
    int c[3];
};

int main()
{
    char a[100];
    memset(a, 'x', 100);
    printf("addr = %p\n", a);
    strncpy(a, "abc", 3);
    strncpy(a + 3, "def", 3);
    a[6] = '\0';
    struct A x;
    printf("size = %d\n", (int)sizeof(struct A));
    memcpy(a, &x, sizeof(struct A));

    return 0;
}
```

编译代码: build.sh

```shell
#!/bin/bash

set -ex
gcc -g -Wall -m32 test.c -o Test
```

