## GDB使用实践经验总结

`GDB`是GNU GCC的一部分，在IT界被奉为DEBUG神器，夹杂很多虚荣心的因素。个人的观点是，`GDB`本身使用并不算方便，如今Linux环境很多类型的程序问题都存在着比`GDB`更好的调试方法或调试工具。对于自己开发的程序，作者本人一般会避免用`gdb`作为首选调试工具，但是实际工作中确实存在一些最难以调试的错误需要用到`GDB`的功能来辅助诊断。

### 1.常用命令

* **bt**

说明：查看当前正在调试的程序的堆栈信息

* **where**

说明：Linux下等效于`bt`

* **list**

说明：显示当前正在调试位置的上下文源码，默认是10行。简便用法为`l`

用法：

```sehll
# 显示当前行的源程序。
$ list

# 显示当前行前面的源程序。
$ list -

# 显示程序第linenum行的周围的源程序。
# 一般是打印当前行的上5行和下5行，默认是10行
$ list <linenum>

# 显示函数名为function的函数的源程序。
$ list <function>

#显示从first行到last行之间的源代码。
$ list <first>, <last>

# 显示从当前行到last行之间的源代码。
$ list , <last>

# 往后显示源代码。
$ list +
```

* **print**

说明：显示指定变量值，简单起见可用`p`代替

用法：

（1）全局变量：直接“`print` + 变量名称”或者“p + 变量名称”，例如：

```shell
# 查看线程局部全局变量errno
$ print errno
```

（2）文件内静态全局变量：“print + '文件名'::变量名称”

```shell
# 注意：原文件名称必须用单引号括住
$ print 'hello_world.c'::m_var
```

（3）函数内局部变量：“print + 函数名::变量名”，必须确保查询的局部变量是当前程序正在执行的上下文中的有效变量。

```shell
# 函数名可以用单引号括住也可以省略单引号
$ print showHashMap::cnt
```

* **cd**

说明：改变调试者的当前工作目录

* **pwd**

说明：显示调试者当前工作目录

### 2.其他重要命令

#### 2.1 gstack工具显示当前进程堆栈

`gstack`可以用来调试正在运行的进程，特别适合用来调试那些由于死锁等原因卡死的程序。使用方法：

```shell
$ gsatck <进程号>
```

`gstack`能够显示进程当前所有线程的堆栈，这是`gstack`的一个优势。如果改为使用`gdb`调试正在运行的进程并使用`bt`查看堆栈，那么只能看到当前调试的线程的堆栈。

**注意**：
（1）调试前应该先进入程序运行时所在目录，否则可能导致堆栈信息不完整（存在??），特别是对于使用了动态库的程序；
（2）应保持编译时源码完整未修改，否则调试信息可能有误。

#### 2.2 gdb调试正在运行的进程

gdb可以用来调试正在运行的进程，命令如下：

```shell
$ gdb [进程启动时的可执行文件] [进程号]
```

**注意**：
（1）调试前应该先进入程序运行时所在目录，否则可能导致堆栈信息不完整（存在??），特别是对于使用了动态库的程序；
（2）应保持编译时源码完整未修改，否则调试信息可能有误。

#### 2.3 gdb调试多线程程序

* **常用命令**

```shell
# 显示当前线程
$ info threads

 # 切换当前正在调试的线程，<线程Id>由info threads命令显示
 $ thread <线程Id> 
 ```
 
 * **实例**

下图中`info threads`显示当前进程有两个线程，Id分别是1和2，2的前面有一个*号表示是当前正在调试的线程

![](/assets/c019_010.jpg)
 
 #### 2.4 /proc/<进程号>/stack查看进程堆栈

* **介绍——与gstack工具对比**
  
  `gstack`工具查看进程堆栈：
  
  （1）最深只能查询到程序用到的glibc库一层的函数，并不能跟踪到当前正在执行的系统库内核函数中。
  （2）是`gstack`命令的优点是，如果程序/依赖库编译时加入了`-g`参数，那么打印出的堆栈信息每一行都有对应的源码信息。
  （3）执行`gstack`命令需要在正确的位置（即链接库、可执行文件等都原样存在，且相对路径都与程序运行时相同），否则打印出的函数调用链的不分寒暑可能无法正确显示（例如某些行显示为??）。

  从这个角度看，`gstack`似乎依赖于动态库和调试信息，是关联“编码-编译-运行”整个程序设计过程的调试。
  
   `cat /proc/<进程号>`打印当前进程栈信息， 不涉及编码和编译，只考虑当前正在执行的程序的运行时。其打印的内容能够深入到系统内核函数（比如驱动函数）中。

* **实例**

`/proc/<线程号>/stack`的效果

```shell
$ cat  /proc/13411/stack
```

![](/assets/c019_011.jpg)

`gstack`工具的效果

```shell
$ gstack 13411
```

![](/assets/c019_012.png)






