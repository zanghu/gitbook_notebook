## C:  内部链接和外部链接

参考资料：《大规模C++程序设计》，机械工业出版社，2014

参考资料：[C语言中定义的结构体，如果并没有实例化为任何一个变量。那这部分代码存放在内存的什么区域？](https://www.zhihu.com/question/41467455)

#### 概念

C/C++编译器的基本（也是最小）编译单元是一个\*.c源文件其输出是一个\*.o文件。很显然，编译器不会为\*.c源文件中的每个变量名称在\*.o文件中生成一个符号，例如：函数内的局部变量不会生成任何符号。

一个编译单元内的“对象”（泛指源码中的各种符号）编译生成的连接条目类型分为内部链接和外部链接；

* 内部链接：静态全局变量，类的非公有静态成员，结构体定义，类定义，联合体定义，枚举类型定义，typedef别名定义，局部变量，内联函数

* 外部链接：全局函数定义（非内联，下同），类成员函数定义（包括静态成员函数），类的静态成员（似乎公有、保护和私有都是）

这里特别需要注意的是：结构体和类定义是内部链接，且编译后生成的可重定位目标文件中一般没有它们的符号。

稍微详细的说明：[C/C++ 的特点就是所有 declarative knowledge 都被丢弃了。剩下的全是 imperative instructs 怎么去用这些 declarative knowledge 的行为，而这些行为都是 compile time 就定的。所以「定义一个结构体，只是告诉编译器结构体变量内部的布局。并不会生成在实际的代码或内存中」这个理解是对的。](https://www.zhihu.com/question/41467455)

**个人分析**：如果编译单元的一个“对象”如果是一个内部链接，那么意味着对该“对象”的引用只局限于当前编译单元，那么就意味着编译期就完全可以确定这些对这些“对象”引用处应填的地址，如果能够保证这些地址与调用它们的代码之间的**相对位置**在后续的链接期保持不变，那么编译器生成间址寻址的代码将始终正确（即使在可执行文件中也是），那么就完全没有必要在\*.o文件中为这些“对象”生成符号。

综上，个人怀疑所有的静态链接“对象”在编译生成的可重定位目标文件\*.o中都没有任何符号，唯一可能的例外就是，对于全局静态变量来说，它的值保存在静态区.data或.rodata或.bss段，代码段如果对此部分的变量有引用，那么在后续链接期就可能需要进行重定位，这就意味着可重定位目标文件有必要为静态全局变量在符号表中生成一个符号。类的非公有静态成员可能也存在相同的情况。


