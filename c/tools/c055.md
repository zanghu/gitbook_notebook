## C: callgrind性能测试工具

`GNU GCC`有自带的程序性能分析工具`gprof`，但是该工具存在很多不便于使用的缺陷：

* 需要重新编译程序，增加编译参数`-pg`后边溢出的程序才能用于分析性能；
* 程序所依赖的所有源码、库文件都需要加上`-pg`后重新编译，对于C运行时库glibc则需要下载专门的版本；
* 实践中动态库无法进行分析（也许是因为我没有正确操作）；

因此，`valgrind`工具套件中提供的`callgrind`运行性能分析工具就显得格外有价值：不需要修改程序编译指令，也就不需要重新编译程序，具有良好的易用性。

需要注意的是，使用`callgrind`检查程序运行后输出的数据文件不适合直接阅读，需要用专用工具解析为图表的形式。

### 1.使用方法

* **编译选项**

编译命令中需要加入`-fsanitize=address`（必填）和`-fno-omit-frame-pointer`（选填）

`-fsanitize=address`: 使用`ASAN`
`-fno-omit-frame-pointer`: 得到更容易理解stack trace

例如：

```shell
$ gcc -g -Wall -fsanitize=address -fno-omit-frame-pointer test.c  -o Test
```

* **环境变量**

配置如下环境变量`ASAN_OPTIONS`

```shell
export ASAN_OPTIONS=halt_on_error=0:use_sigaltstack=0:detect_leaks=1:malloc_context_size=15
```

选项功能说明

```shell
# halt_on_error=0：检测内存错误后继续运行
# detect_leaks=1:使能内存泄露检测
# malloc_context_size=15：内存错误发生时，显示的调用栈层数为15
# log_path=/home/xos/asan.log:内存检查问题日志存放文件路径, 这时检查结果不会再输出到屏幕
# suppressions=$SUPP_FILE:屏蔽打印某些内存错误
```

* **运行方式**

运行方式没有变化，任然是

```shell
$ ./Test
```

### 2.优势

* 速度快，比正常运行只慢2倍左右，远快于`valgrind`；

* 能够检查栈越界；

* 支持任意优化级别`-O1`、`-O2`...
