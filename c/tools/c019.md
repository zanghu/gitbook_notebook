## GDB使用实践经验总结

### 1.常用命令

* **bt**

说明：查看当前正在调试的程序的堆栈信息

* **where**

说明：Linux下等效于`bt`

* **list**

说明：显示当前正在调试位置的上下文源码，默认是10行

示例：

```sehll
# 显示当前行的源程序。
$ list

# 显示当前行前面的源程序。
$ list -

# 显示程序第linenum行的周围的源程序。
# 一般是打印当前行的上5行和下5行，默认是10行
$ list <linenum>

# 显示函数名为function的函数的源程序。
$ list <function>

#显示从first行到last行之间的源代码。
$ list <first>, <last>

# 显示从当前行到last行之间的源代码。
$ list , <last>

# 往后显示源代码。
$ list +
```

* **print**

**说明**：显示指定变量值，简单起见可用`p`代替

**用法**：

全局变量：直接“`print` + 变量名称”或者“p + 变量名称”，例如：

```shell
# 查看线程局部全局变量errno
$ print errno
```

文件内静态全局变量：“print + '文件名'::变量名称”

```shell
# 注意：原文件名称必须用单引号括住
$ print 'hello_world.c'::m_var
```

函数内局部变量：“print + 函数名::变量名”，必须确保查询的局部变量是当前程序正在执行的上下文中的有效变量。

```shell
# 函数名可以用单引号括住也可以省略单引号
$ print showHashMap::cnt
```



### 2.其他重要命令

* **gstack工具**

`gstack`可以用来调试正在运行的进程，特别适合用来调试那些由于死锁等原因卡死的程序。使用方法：

```shell
$ gsatck [进程号]
```

`gstack`能够显示进程当前所有线程的堆栈，这是`gstack`的一个优势。如果改为使用`gdb`调试正在运行的进程并使用`bt`查看堆栈，那么只能看到当前调试的线程的堆栈。

**注意**：
（1）调试前应该先进入程序运行时所在目录，否则可能导致堆栈信息不完整（存在??），特别是对于使用了动态库的程序；
（2）应保持编译时源码完整未修改，否则调试信息可能有误。

* **gdb调试正在运行的进程**

gdb可以用来调试正在运行的进程，命令如下：

```shell
$ gdb [进程启动时的可执行文件] [进程号]
```

**注意**：
（1）调试前应该先进入程序运行时所在目录，否则可能导致堆栈信息不完整（存在??），特别是对于使用了动态库的程序；
（2）应保持编译时源码完整未修改，否则调试信息可能有误。








