## C: Linux环境下使用nm命令查看lib库中的符号

参考资料：[Can someone explain about Linux library naming?](https://stackoverflow.com/questions/663209/can-someone-explain-about-linux-library-naming)

Linux下动态库（lib*.so）的命名有一定的规则可循，本文重点介绍这些内容。

### 1.术语：向前兼容与向后兼容

&emsp&emsp**向前兼容**的英文为 Forwards Compatibility，Forward有“将来”的含义。向前兼容隐含的主语是“过去的版本”，即向前兼容就是指：过去的版本支持现在版本生成的数据。比如你的CD盘可以放在CD光驱播放，也可以放在DVD光驱播放。

&emsp&emsp**向后兼容**的英文为Backwards Compatibility，Backward有“回头”的意思。向后兼容隐含的主语是“现在的版本”，即向后兼容就是指：现在的版本可以支持以前的版本数据。比如你的PC的DVD光驱也可以播放CD盘。
 
#### 2.Linux动态库命名传统

#### 2.1 Linux环境下动态库发布——一式三份

Linux下第三方发布的动态库文件通常包括三个文件，而静态库文件只包含一个. 以cudnn的7.1.4版本例来说（为了清晰期间下面的内容有所省略）：

```shell
$ ls -l
总用量 655324
lrwxrwxrwx libcudnn.so -> libcudnn.so.7 # linker name: libcudnn.so
lrwxrwxrwx libcudnn.so.7 -> libcudnn.so.7.1.4 # soname: libcudnn.so.7
-rwxrwxr-x libcudnn.so.7.1.4 # real name: libcudnn.so.7.1.4
-rw-rw-r-- libcudnn_static.a # 静态库文件
```

按照[Wheeler](http://tldp.org/HOWTO/Program-Library-HOWTO/shared-libraries.html)的说明, 每个动态库一般包括`real name`、`soname`和`linker name`. 

* **real name**: 动态库的`real name`是这三个文件中唯一一个不是软链接的文件，它是编译动态库时的`-o`参数指明的库文件名. 

* **soname**: 是一个指向`real name`的软链接, 其名称一般只包括主版本号，主版本号发生改变一般意味着新版本库的接口与之前版本库的接口不再兼容. 

* **linker name**: 一般不包含任何版本号, 在被使用动态库的应用系统链接时最常被使用.

#### 2.2 Linux环境下动态库版本命名原则

There is some confusion regarding the intent and purpose of each of the numbers in the real name of the library. I personally think that the Apache Portable Runtime Project does a good job of explaining the rules for when each number should be incremented.

In short, the versioning numbers can be thought of as libfoo.MAJOR.MINOR.PATCH.

PATCH is incremented for changes that are both forwards and backwards compatible with other versions.
MINOR should be incremented if the new version of the library is source and binary compatible with the old version. Different minor versions are backwards compatible, but not necessarily forwards compatible, with each other.
MAJOR is incremented when a change is introduced that breaks the API, or is otherwise incompatible with the previous version.
What this means is that PATCH releases may only differ internally, for example in the way a function is implemented. Changing the API, the signature of public functions, or the interpretation of function parameters is not allowed.

A new MINOR release may introduce new functions or constants, and deprecate existing functions, but may not remove anything that is externally exposed. This ensures backwards compatibility. In other words, a minor release 1.12.3 may be used to replace any other 1.12.x or earlier version, such as 1.11.2 or 1.5.0. It is not a drop in replacement for 1.16.1 though, since different minor versions are not necessarily forward compatible.

Any kind of change can be made with the release of a new MAJOR version; constants may be removed or changed, (deprecated) functions may be removed, and of course, any changes that would normally increment the MINOR or PATCH number (though it might be worth it to backport such changes to the previous MAJOR version also).

Of course, there are factors that can complicate this further; you might have developed your library so that the same file may hold multiple versions simultaneously, or you might use libtool's convention of current:revision:age. But that's a discussion for another time. :)


















