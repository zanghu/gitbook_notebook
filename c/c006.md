## C: Linux环境下使用nm命令查看lib库中的符号

参考资料：[Can someone explain about Linux library naming?](https://stackoverflow.com/questions/663209/can-someone-explain-about-linux-library-naming)

参考资料：[Shared libraries](http://man7.org/conf/lca2006/shared_libraries/index.html)

Linux下动态库（lib*.so）的命名有一定的规则可循，本文重点介绍这些内容。

### 0.术语：向前兼容与向后兼容

&emsp&emsp**向前兼容**的英文为 Forwards Compatibility，Forward有“将来”的含义。向前兼容隐含的主语是“过去的版本”，即向前兼容就是指：过去的版本支持现在版本生成的数据。比如你的CD盘可以放在CD光驱播放，也可以放在DVD光驱播放。

&emsp&emsp**向后兼容**的英文为Backwards Compatibility，Backward有“回头”的意思。向后兼容隐含的主语是“现在的版本”，即向后兼容就是指：现在的版本可以支持以前的版本数据。比如你的PC的DVD光驱也可以播放CD盘。
 
### 1.Linux动态库命名传统

本节首先讲解Linux动态库的发布传统（主要是关于带有不同版本号的动态库的名称和用途上的区别），之后讲解每个版本号的含义和修改原则。

#### 1.1 Linux环境下动态库发布——一式三份

Linux下第三方发布的动态库文件通常包括三个文件，而静态库文件只包含一个. 以cudnn的7.1.4版本例来说（为了清晰期间下面的内容有所省略）：

```shell
$ ls -l
总用量 655324
lrwxrwxrwx libcudnn.so -> libcudnn.so.7 # linker name: libcudnn.so
lrwxrwxrwx libcudnn.so.7 -> libcudnn.so.7.1.4 # soname: libcudnn.so.7
-rwxrwxr-x libcudnn.so.7.1.4 # real name: libcudnn.so.7.1.4
-rw-rw-r-- libcudnn_static.a # 静态库文件
```

按照[Wheeler](http://tldp.org/HOWTO/Program-Library-HOWTO/shared-libraries.html)的说明, 每个动态库一般包括`real name`、`soname`和`linker name`. 

* **real name**: 动态库的`real name`是这三个文件中唯一一个不是软链接的文件，它是编译动态库时的`-o`参数指明的库文件名. 

* **soname**: 是一个指向`real name`的软链接, 其名称一般只包括主版本号，主版本号发生改变一般意味着新版本库的接口与之前版本库的接口不再兼容. 

* **linker name**: 一般不包含任何版本号, 在被使用动态库的应用系统链接时最常被使用.

#### 1.2 Linux环境下动态库版本命名原则

本节将详细介绍上一小节中提到的动态库的`real name`的版本号所隐含的库文件作者的意图和目的，并介绍增加版本号每个部分的时机.本文推荐采用**《Apache Portable Runtime Project》**中所介绍的版本号每部分的增加原则.

简而言之, 版本号可以被看作形如`libfoo.MAJOR.MINOR.PATCH`.

* **PATCH** 只有当修改后的软件既满足**向前兼容**又满足**向后兼容**时，才被允许以只增加`PATCH`部分数字的方式发布。

* **MINOR** 只有当修改后的软件满足**向后兼容**时（但不一定必须是前相兼容的），才被允许以只增加`MINOR`部分数字而不增加`MAJOR`部分数字的方式发布。具有相同`MAJOR`和不同`MINOR`的动态库之间是"source and binary compatible"的.

* **MAJOR** is incremented when a change is introduced that breaks the API, or is otherwise incompatible with the previous version.

What this means is that PATCH releases may only differ internally, for example in the way a function is implemented. Changing the API, the signature of public functions, or the interpretation of function parameters is not allowed.

A new `MINOR` release may introduce new functions or constants, and deprecate existing functions, but may not remove anything that is externally exposed. This ensures backwards compatibility. In other words, a minor release 1.12.3 may be used to replace any other 1.12.x or earlier version, such as 1.11.2 or 1.5.0. It is not a drop in replacement for 1.16.1 though, since different minor versions are not necessarily forward compatible.

Any kind of change can be made with the release of a new `MAJOR` version; constants may be removed or changed, (deprecated) functions may be removed, and of course, any changes that would normally increment the `MINOR` or `PATCH` number (though it might be worth it to backport such changes to the previous `MAJOR` version also).

Of course, there are factors that can complicate this further; you might have developed your library so that the same file may hold multiple versions simultaneously, or you might use libtool's convention of current:revision:age. But that's a discussion for another time. :)

### 2.Linux环境下编译符合命名原则的动态库

**参考资料**：[Creating Shared Libraries Using Standard Naming Conventions](http://man7.org/conf/lca2006/shared_libraries/slide6.html)

We can create a shared library using standard naming conventions as follows:

**Step 1**: Create the shared library with real name libdemo.so.1.0.1 and soname libdemo.so.1.

```shell
$ gcc -fPIC -g -c -Wall mod1.c mod2.c mod3.c
$ gcc -shared -Wl,-soname,libdemo.so.1 -o libdemo.so.1.0.1 \
          mod1.o mod2.o mod3.o
```

**Step 2**: Create symbolic links for the soname and linker name:

```shell
$ ln -s libdemo.so.1.0.1 libdemo.so.1
$ ln -s libdemo.so.1 libdemo.so
$ ls -l libdemo.so* | cut -c 1-11,55-        # Verify the setup
lrwxrwxrwx  libdemo.so -> libdemo.so.1
lrwxrwxrwx  libdemo.so.1 -> libdemo.so.1.0.1
-rwxr-xr-x  libdemo.so.1.0.1
```

**Step 3**: Build executable using the linker name:

```shell
$ gcc -g -Wall -o ./prog prog.c -L. -ldemo
```

**Step 4**: Run the program as usual:

```shell
$ LD_LIBRARY_PATH=. ./prog
Called mod1-x1
Called mod2-x2
```

















