## C: 二维指针与二维数组在使用中的注意事项

一维数组和指针的用法非常类似，但是二维指针和二维数组在用法上存在明显的区别，甚至显得很不“兼容”（实际上更高维指针和数组间也是如此）。

### 1.二维指针的元素是一维数组，二维指针的元素是指针

**测试代码**

```c
int a[10][20]; // 数组a可以看作的每个元素是`int [20]`的一维数组
fprintf(stdout, "a addr: %p, a + 1 addr : %p, delta = %d\n", \
        a, a + 1, (int)((char *)(a + 1) - (char *)a)); // a每增加一个单位, 地址变化sizeof(int [20])
```

**执行后**

![](/assets/c066_01.PNG)

**结论**

二维指针变量和二维数组变量的“加法运算”具有不同行为。因此，

（1）二维数组变量名不能作为作为函数的二维指针参数传入，因为这会导致指针参数的**“加法运算”**产生错误行为。同样的理由，二维指针也不能作为函数的二维数组参数传入函数；

（2）n维数组作为函数参数时，后面的`n-1`维必须给出每一层的具体维数，因为只有这样，编译器才能无歧义的理解该参数在函数内部**加法运算**的含义。这也再次展示了C语言面向编译器的语法特性。

### 2.结构体的数组成员是直接寻址，而指针成员是间接寻址

试想，如果将当前进程A创建的内存数据放在一个共享内存中，之后有其他进程B打连接这个共享内存，并读取共享内存中的一个下面代码定义的`struct X`结构体指针`obj`，那么由于进程B连接到共享内存的起始地址与A创建该共享内存时的共享内存起始地址不同，共享内存忠所有地址都发生了一个“偏移”，在修正这个偏移时，`obj->a`和`obj->b`的修正方法是不同的。

```c 
struct X
{
    char a[32]; // 只要结构体对象obj的地址是正确的, 那么obj->a指向的就是正确的字符串地址
    char *b; // 即使结构体对象obj的地址是正确的, obj->b的地址也必须修正后才能指向正确的字符串地址
}
```

### 3.一点参考资料

简单翻阅一下，就会发现很多C语言技术书籍中都有专门章节介绍指针与数组的区别，下面给出一些有用的参考书。

**参考资料**

C陷阱与缺陷, Ch-3.1

C语言深度剖析, Ch-4

