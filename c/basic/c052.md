## C: 指针void *的性质

C语言中的内存池、多态、回调等数据结构、或机制的实现严重依赖于`void *`指针，那么这些相关代码中令人眼花缭乱的各种指针类型转换的安全性如何呢？

#### 问题1: 任何类型指针与void *指针相互转换是否是安全、可逆的？

答案：是安全、可逆的。

参考如下的`ISO C99/11`中的叙述：
> 6.3.2.3 Pointers
> 1 A pointer to void may be converted to or from a pointer to any object type. A pointer to
any object type may be converted to a pointer to void and back again; the result shall
compare equal to the original pointer.
> 2...

#### 问题2: 不同类型的指针，其表示方式是否相同（指针类型转化前后是否相等）？

答案：根据`ISO C99/11`，不同类型不一定有相同的表示方式。

参考如下的`ISO C99/11`中的叙述：
> 6.2.5 Types
> ...
>28 A pointer to void shall have the same representation and alignment requirements as a
pointer to a character type. Similarly, pointers to qualified or unqualified versions of
compatible types shall have the same representation and alignment requirements. All
pointers to structure types shall have the same representation and alignment requirements
as each other. All pointers to union types shall have the same representation and
alignment requirements as each other. Pointers to other types need not have the same
representation or alignment requirements
> ...

综上可见，虽然`void *`指针作为一种“一般等价物”可以用于可逆的与任何类型指针进行相互转化，但这并不意味着转化前后其*内存表示*和*对齐方式*是不变的。`ISO C`只保证:
```
（1）`void *`类型与`char *`类型之间；
（2）兼容的指针类型之间；
（3）所有指向`struct`对象的指针类型之间；
（4）所有指向`union`对象的指针类型之间；
（5）以上四点提到的指针类型之外的指针类型之间；
```
以上每一点中的指针类型具有相同的内存表示和对齐方式。


#### 问题3: void *指针进行四则运算触发编译器警告怎么办？

